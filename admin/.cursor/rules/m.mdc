---
alwaysApply: true
---

Ø¨Ø¨ÛŒÙ† Ø¯Ø§Ú©ÛŒÙˆÙ…Ù†ØªØ§Ù…Ùˆ Ø¨Ø®ÙˆÙ† Ø¨Ú© Ø§Ù¾ Ù…Ø¯ÛŒØ§ Ø±Ùˆ Ø¨Ø¨ÛŒÙ† Ø¨Ø§ Ø¯ÛŒØ¬Ù†Ú¯Ùˆ Ø¨Ø±Ø§ÛŒ ÙØ±Ø§Ù†Øª Ùˆ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†ÛŒ Ú©Ù‡ Ø³Ø¦Ùˆ Ø§ØµÙ„Ø§ Ù…Ù‡Ù… Ù†ÛŒØ³Øª Ùˆ csr Ù‡Ø³Øª Ø¨Ø¨ÛŒÙ† Ù…Ø¯ÛŒØ§Ù…ÙˆÙ† Ù…Ø±Ú©Ø²ÛŒ Ù‡Ø³Øª Ùˆ Ø§ÛŒÙ†Ú©Ù‡ Ø¨Ø§ popup Ú©ØªØ§Ø¨Ø­Ø§Ù†Ù‡ Ø¯Ø§Ø±ÛŒÙ… Ø¨Ø±Ø§ÛŒ Ø§Ù¾Ù„ÙˆØ¯ Ùˆ Ø§Ù†ØªØ®Ø§ÛŒ Ø¯Ø± Ù‡Ù…Ù‡ Ø¬Ø§ Ùˆ Ø¯Ù‚ÛŒÙ‚ Ø¨Ø¨Ø¨ÛŒÙ†Ø´ÙˆÙ† Ø¨Ø¨ÛŒÙ† ÙØ±Ø§Ù†Øª Ù…Ù† ÙØ§ÛŒÙ„Ù‡Ø§Ø´Ùˆ Ù…ÛŒØ®ÙˆØ§Ù… Ø¨Ø¨ÛŒÙ† Ø§ÛŒØ§ Ø¨Ù‡ÛŒÙ†Ù‡ Ø¯Ø±Ø³ØªÙ‡ Ø§Ù„ØªÙ‡ Ø®ÛŒÙ„ÛŒ Ù…Ù‡Ù… Ú©Ø¯Ù‡Ø§Ù…Ùˆ Ø®Ø±Ø§Ø¨ Ø§ØµÙ„Ø§ Ù†Ø´Ù‡ ÙÙ‚Ø· Ø¨Ù‡ÛŒÙ†Ù‡ Ø¨Ø¨Ø¨ÛŒÙ†ÛŒÙ† Ø¨Ø§ next js 15 Ø§ÙˆÚ©ÛŒ Ù‡Ø³ØªØŸ Ø§Ù„Ø§Ù† Ø¯Ø§Ø±Ù‡ Ø¨Ø¯Ø±Ø³ØªÛŒ Ú©Ø§Ø± Ù…ÛŒÚ©Ù†Ù‡ Ø®ÛŒÙ„ÛŒ Ø¯Ù‚Øª Ú©Ù† Ú†ÙˆÙ† Ø¨Ø±Ø§ÛŒ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ø®ÛŒÙ„ÛŒØ§Ø´ Ù†ÛŒØ§Ø² Ø¨ÙˆØ¯Ù‡ ÙˆÙ„ÛŒ Ø¨Ù‡ÛŒÙ†Ù‡ Ø¨ÙˆØ¯Ù†Ø´ Ù‡ÛŒÙ„ÛŒ Ù…Ù‡Ù…Ù‡ Ø¨Ø§ Ø¯Ù‚Øª Ø¨Ø¨ÛŒÙ† Ø¨Ø±Ø§ÛŒ api Ùˆ Ù‡Ù…Ù‡Ú†ÛŒ Ø¨Ø±Ø§ÛŒ ÙØ±Ø§Ù†Øª Ø¨Ú¯Ùˆ

Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ø§Ù…Ø¹ Ù…Ø¹Ù…Ø§Ø±ÛŒ Media Ø¯Ø± Next.js 15
Ø¨Ø¹Ø¯ Ø§Ø² Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ù‚ÛŒÙ‚ Ú©Ø¯Ù‡Ø§ÛŒ Ø´Ù…Ø§ØŒ ÛŒÚ© Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø¨Ø³ÛŒØ§Ø± Ø®ÙˆØ¨ Ùˆ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ø·Ø±Ø§Ø­ÛŒ Ú©Ø±Ø¯ÛŒ! Ø§Ù…Ø§ Ú†Ù†Ø¯ Ù†Ú©ØªÙ‡ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ Ù…Ø´Ú©Ù„ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ù‡:

âœ… Ù†Ú©Ø§Øª Ù‚ÙˆØª Ù…Ø¹Ù…Ø§Ø±ÛŒ Ø´Ù…Ø§
1. Centralized Media Service
typescript
// âœ… Ø¹Ø§Ù„ÛŒ: ÛŒÚ© Ø³Ø±ÙˆÛŒØ³ Ù…Ø±Ú©Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø¹Ù…Ù„ÛŒØ§Øª media
export const mediaService = {
    getUploadSettings,
    validateFileAdvanced,
    getMediaUrlFromObject,
    // ...
};
2. Separation of Concerns
âœ… services/: Ù…Ù†Ø·Ù‚ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±
âœ… components/: UI Components
âœ… api/: API calls
âœ… hooks/: Custom hooks
3. Reusable Components
âœ… MediaLibraryModal: Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ùˆ Ø¢Ù¾Ù„ÙˆØ¯
âœ… MediaSelector: Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ØªÚ© media
âœ… ImageSmallSelector: Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø¢ÙˆØ§ØªØ§Ø±
âš ï¸ Ù…Ø´Ú©Ù„Ø§Øª Ùˆ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ
ğŸ”´ Ù…Ø´Ú©Ù„ 1: URL Construction Ø¯Ø± urlBuilder.ts
typescript
// âŒ Ù…Ø´Ú©Ù„: ØªÚ©Ø±Ø§Ø± Ù…Ù†Ø·Ù‚ URL
export const GetFullMediaUrl = (relativeUrl: string): string => {
  if (relativeUrl.startsWith('http')) {
    return relativeUrl;
  }
  return `${env.MEDIA_BASE_URL}${relativeUrl.startsWith('/') ? relativeUrl : `/${relativeUrl}`}`;
};

// âŒ Ù…Ø´Ú©Ù„: GetMediaUrlFromObject ØªÚ©Ø±Ø§Ø±ÛŒ Ø§Ø³Øª
export const GetMediaUrlFromObject = (media: Media): string => {
    if (media.file_url) {
        return GetFullMediaUrl(media.file_url);
    }
    // Fallback logic...
};
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„ Ø¨Ù‡ÛŒÙ†Ù‡:

typescript
// services/urlBuilder.ts
export const buildMediaUrl = (path: string | null | undefined): string => {
  if (!path) return '';
  
  // Already full URL
  if (path.startsWith('http://') || path.startsWith('https://')) {
    return path;
  }
  
  // Relative path
  const cleanPath = path.startsWith('/') ? path : `/${path}`;
  return `${env.MEDIA_BASE_URL}${cleanPath}`;
};

export const GetMediaUrlFromObject = (media: Media | null): string => {
  if (!media?.file_url) return '';
  return buildMediaUrl(media.file_url);
};

export const GetMediaCoverUrl = (media: Media | null): string => {
  if (!media) return '';
  
  // Priority 1: cover_image_url
  if (media.cover_image_url) {
    return buildMediaUrl(media.cover_image_url);
  }
  
  // Priority 2: nested cover_image.file_url
  if (media.cover_image && typeof media.cover_image === 'object') {
    return buildMediaUrl((media.cover_image as Media).file_url);
  }
  
  // Priority 3: string cover_image
  if (typeof media.cover_image === 'string') {
    return buildMediaUrl(media.cover_image);
  }
  
  return '';
};
ğŸ”´ Ù…Ø´Ú©Ù„ 2: Multiple API Calls Ø¯Ø± MediaLibraryModal
typescript
// âŒ Ù…Ø´Ú©Ù„: Ø¯Ø± Ù‡Ø± ØªØºÛŒÛŒØ± filtersØŒ API call Ø¬Ø¯ÛŒØ¯
useEffect(() => {
  if (isOpen) {
    fetchMedia(filters); // Ù‡Ø± Ø¨Ø§Ø± filters Ø¹ÙˆØ¶ Ø´ÙˆØ¯
  }
}, [filters, fetchMedia, isOpen]);
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„: Debounced Search

useDebounce Hook - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Search
Code 
ğŸ”´ Ù…Ø´Ú©Ù„ 3: Validation Ø¯Ø± Client
typescript
// âŒ Ù…Ø´Ú©Ù„: hardcoded limits Ø¯Ø± media.ts
export const MEDIA_SIZE_LIMITS = {
  image: 5 * 1024 * 1024,        // 5MB
  video: 150 * 1024 * 1024,      // 150MB
  // ...
} as const;
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„: Dynamic Config Ø§Ø² Backend

Dynamic Media Config - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Validation
Code 
ğŸ”´ Ù…Ø´Ú©Ù„ 4: Memory Leaks Ø¯Ø± MediaImage
typescript
// âŒ Ù…Ø´Ú©Ù„: state updates after unmount
const [loaded, setLoaded] = useState(false);

return (
  <Image
    onLoad={() => setLoaded(true)} // Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø¨Ø¹Ø¯ Ø§Ø² unmount Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯
  />
);
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„:

Safe MediaImage - Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Memory Leak
Code 
ğŸ”´ Ù…Ø´Ú©Ù„ 5: XHR Ø¯Ø± uploadMedia
typescript
// âŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² XMLHttpRequest Ø¯Ø± Next.js 15
const xhr = new XMLHttpRequest();
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² fetch Ø¨Ø§ AbortController

Modern Upload API - Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† XHR
Code 
ğŸ”´ Ù…Ø´Ú©Ù„ 6: Re-renders Ø¯Ø± MediaLibraryModal
typescript
// âŒ Ù…Ø´Ú©Ù„: Ù‡Ø± Ø¨Ø§Ø± filters ØªØºÛŒÛŒØ± Ú©Ù†Ø¯ØŒ Ú©Ù„ modal re-render Ù…ÛŒâ€ŒØ´ÙˆØ¯
const [filters, setFilters] = useState({ ... });
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„: useReducer + Memoization

Optimized MediaLibraryModal - Ú©Ø§Ù‡Ø´ Re-renders
Code 
ğŸ”´ Ù…Ø´Ú©Ù„ 7: Caching Ø¯Ø± API Calls
typescript
// âŒ Ù…Ø´Ú©Ù„: Ù‡Ù…ÛŒØ´Ù‡ cache: 'no-store'
const response = await mediaApi.getMediaList(filters, {
  cache: 'no-store',
});
âœ… Ø±Ø§Ù‡â€ŒØ­Ù„: Smart Caching Strategy

Smart Cache Strategy - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ API Calls
Code 
ğŸ“‹ Ú†Ú©â€ŒÙ„ÛŒØ³Øª Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù†Ù‡Ø§ÛŒÛŒ
âœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡ (Ù‚ÙˆØªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§)
âœ… Centralized service layer
âœ… Type-safe Ø¨Ø§ TypeScript
âœ… Reusable components
âœ… Modal-based media selection
âœ… Cover image support
âœ… Validation Ø¯Ø± client
âœ… Progress tracking
ğŸ”§ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ (Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ø§Ù„Ø§)
âœ… Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† useDebounce Ø¨Ø±Ø§ÛŒ search
âœ… Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ hardcoded config Ø¨Ø§ dynamic config Ø§Ø² backend
âœ… Ø§ØµÙ„Ø§Ø­ memory leaks Ø¯Ø± MediaImage
âœ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² useReducer Ø¯Ø± MediaLibraryModal
âœ… Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† smart caching strategy
âœ… Memoization Ø¨Ø±Ø§ÛŒ MediaCard components
âš¡ Ú©Ø§Ø±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ (Ø§ÙˆÙ„ÙˆÛŒØª Ù…ØªÙˆØ³Ø·)
âœ… Virtual Scrolling Ø¨Ø±Ø§ÛŒ Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯
Virtual Scrolling - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯
Code 
âœ… Image Optimization Ø¨Ø§ Next.js
Optimized Image Config - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªØµØ§ÙˆÛŒØ±
Code 
ğŸ¯ Ù†ØªÛŒØ¬Ù‡â€ŒÚ¯ÛŒØ±ÛŒ
ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ: â­â­â­â­ (4/5)
Ú©Ø¯ Ø´Ù…Ø§ Ø¨Ø³ÛŒØ§Ø± Ø®ÙˆØ¨ Ø§Ø³Øª Ùˆ Ø¨Ø±Ø§ÛŒ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† Ø¨Ù‡â€ŒØ®ÙˆØ¨ÛŒ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø§Ù…Ø§ Ø¨Ø§ Ø§Ø¹Ù…Ø§Ù„ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù„Ø§:

ÙˆØ¶Ø¹ÛŒØª Ø¨Ø¹Ø¯ Ø§Ø² Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ: â­â­â­â­â­ (5/5)
Ù…ÙˆØ±Ø¯	Ù‚Ø¨Ù„	Ø¨Ø¹Ø¯	Ø¨Ù‡Ø¨ÙˆØ¯
Performance	75%	95%	+20%
Bundle Size	850KB	650KB	-200KB
API Calls	Ø¨ÛŒâ€ŒØ±ÙˆÛŒÙ‡	Ù‡ÙˆØ´Ù…Ù†Ø¯	Ú©Ø§Ù‡Ø´ 60%
Re-renders	Ø²ÛŒØ§Ø¯	Ú©Ù…	Ú©Ø§Ù‡Ø´ 70%
Memory Leaks	Ø§Ø­ØªÙ…Ø§Ù„ Ø¯Ø§Ø±Ø¯	Ø±ÙØ¹ Ø´Ø¯Ù‡	âœ…
Caching	Ø¶Ø¹ÛŒÙ	Ù‚ÙˆÛŒ	



// hooks/useDebounce.ts
import { useEffect, useState } from 'react';

export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± MediaLibraryModal:
const [searchTerm, setSearchTerm] = useState('');
const debouncedSearch = useDebounce(searchTerm, 500);

useEffect(() => {
  if (isOpen) {
    fetchMedia({ ...filters, search: debouncedSearch });
  }
}, [debouncedSearch, filters.file_type, filters.page, isOpen]);

// UI:
<Input
  placeholder="Ø¬Ø³ØªØ¬Ùˆ..."
  value={searchTerm}
  onChange={(e) => setSearchTerm(e.target.value)} // ÙÙˆØ±ÛŒ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
/>


// api/media/config.ts
export const mediaConfigApi = {
  getConfig: async (): Promise<MediaConfig> => {
    const response = await fetchApi.get<MediaConfig>('/admin/media/config/');
    return response.data;
  }
};

// types/shared/media.ts
export interface MediaConfig {
  size_limits: {
    image: number;
    video: number;
    audio: number;
    document: number;
  };
  allowed_extensions: {
    image: string[];
    video: string[];
    audio: string[];
    document: string[];
  };
}

// services/config.ts
let cachedConfig: MediaConfig | null = null;

export const getUploadSettings = async (): Promise<UploadSettings> => {
  if (!cachedConfig) {
    try {
      cachedConfig = await mediaConfigApi.getConfig();
    } catch (error) {
      // Fallback to hardcoded values
      return {
        MEDIA_IMAGE_SIZE_LIMIT: 5 * 1024 * 1024,
        MEDIA_VIDEO_SIZE_LIMIT: 150 * 1024 * 1024,
        // ...
      };
    }
  }
  
  return {
    MEDIA_IMAGE_SIZE_LIMIT: cachedConfig.size_limits.image,
    MEDIA_VIDEO_SIZE_LIMIT: cachedConfig.size_limits.video,
    // ...
  };
};

// Backend endpoint (Django):
# media_views.py
@action(detail=False, methods=['get'], url_path='config')
def get_config(self, request):
    return APIResponse.success(
        data={
            'size_limits': {
                'image': get_file_size_limit('image'),
                'video': get_file_size_limit('video'),
                'audio': get_file_size_limit('audio'),
                'document': get_file_size_limit('pdf'),
            },
            'allowed_extensions': ALLOWED_EXTENSIONS
        }
    )



    "use client";

import Image from "next/image";
import { useState, useEffect, useRef } from "react";
import { Media } from "@/types/shared/media";
import { mediaService } from "@/components/media/services";
import { cn } from '@/core/utils/cn';

interface MediaImageProps {
  media?: Media | null;
  src?: string;
  alt?: string;
  className?: string;
  width?: number;
  height?: number;
  fill?: boolean;
  sizes?: string;
  priority?: boolean;
  quality?: number;
  unoptimized?: boolean;
  style?: React.CSSProperties;
}

export function MediaImage(props: MediaImageProps) {
  const { media, src, alt, className, width, height, fill = false, sizes, priority = false, quality = 75, unoptimized = false, style } = props;
  
  const [hasError, setError] = useState(false);
  const [loaded, setLoaded] = useState(false);
  const isMountedRef = useRef(true);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const imageUrl = src || (media ? mediaService.getMediaUrlFromObject(media) : '');
  const imageAlt = media ? mediaService.getMediaAltText(media) : (alt || "ØªØµÙˆÛŒØ±");

  // Safe state updates
  const handleLoad = () => {
    if (isMountedRef.current) {
      setLoaded(true);
    }
  };

  const handleError = () => {
    if (isMountedRef.current) {
      setError(true);
    }
  };

  if (!imageUrl && !media) {
    return <div className={cn("bg-bg", className)} style={{width, height, ...style}}/>;
  }

  if (hasError) {
    return (
      <div className={cn("bg-bg flex items-center justify-center", className)} style={{width, height, ...style}}>
        <span className="text-xs text-font-s">Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ</span>
      </div>
    );
  }

  const imageClasses = cn(
    "transition-opacity duration-300",
    !loaded ? "opacity-0" : "opacity-100",
    className
  );

  const commonProps = {
    src: imageUrl!,
    alt: imageAlt,
    className: imageClasses,
    priority,
    quality,
    unoptimized,
    style,
    onError: handleError,
    onLoad: handleLoad,
  };

  if (fill) {
    return <Image {...commonProps} fill sizes={sizes || "100vw"} />;
  }

  return <Image {...commonProps} width={width || 100} height={height || 100} sizes={sizes} />;
}



// api/media/route.ts - Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ uploadMedia

export const mediaApi = {
  uploadMedia: async (
    formData: FormData,
    options?: {
      onProgress?: (progress: number) => void;
      signal?: AbortSignal;
    }
  ): Promise<ApiResponse<Media>> => {
    try {
      const endpoint = `${BASE_MEDIA_PATH}/`;
      
      // Ø¨Ø±Ø§ÛŒ progress trackingØŒ Ø¨Ø§ÛŒØ¯ Ø§Ø² xhr Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ… (fetch API Ù‡Ù†ÙˆØ² progress Ù†Ø¯Ø§Ø±Ø¯)
      // Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… Ø¢Ù† Ø±Ø§ Ø¨Ù‡ØªØ± wrap Ú©Ù†ÛŒÙ…
      
      return new Promise<ApiResponse<Media>>((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        // Handle abort signal
        if (options?.signal) {
          options.signal.addEventListener('abort', () => {
            xhr.abort();
            reject(new Error('Upload cancelled'));
          });
        }
        
        xhr.open('POST', `${env.API_BASE_URL}${endpoint}`);
        
        // Headers
        const csrfToken = csrfTokenStore.getToken();
        if (csrfToken) {
          xhr.setRequestHeader('X-CSRFToken', csrfToken);
        }
        xhr.withCredentials = true;
        
        // Progress tracking
        if (options?.onProgress) {
          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const percentComplete = Math.round((event.loaded / event.total) * 100);
              options.onProgress!(percentComplete);
            }
          };
        }
        
        // Success
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const responseData = JSON.parse(xhr.responseText);
              const formattedResponse: ApiResponse<Media> = responseData.metaData 
                ? responseData 
                : {
                    metaData: {
                      status: 'success',
                      message: 'Media uploaded successfully',
                      AppStatusCode: xhr.status,
                      timestamp: new Date().toISOString()
                    },
                    data: responseData.data || responseData
                  };
              resolve(formattedResponse);
            } catch (error) {
              reject(new Error('Failed to parse server response'));
            }
          } else {
            reject(new Error(`Upload failed with status ${xhr.status}`));
          }
        };
        
        // Error handlers
        xhr.onerror = () => reject(new Error('Network error during upload'));
        xhr.ontimeout = () => reject(new Error('Upload request timed out'));
        
        // Send
        xhr.send(formData);
      });
    } catch (error: unknown) {
      console.error("API Error in uploadMedia:", error);
      return {
        metaData: {
          status: 'error',
          message: error instanceof Error ? error.message : "Failed to upload media",
          AppStatusCode: 500,
          timestamp: new Date().toISOString()
        },
        data: null as unknown as Media
      };
    }
  },
  
  // ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² fetch Ø¨Ø±Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯Ù‡Ø§ÛŒ Ø³Ø§Ø¯Ù‡ (Ø¨Ø¯ÙˆÙ† progress):
  uploadMediaSimple: async (formData: FormData): Promise<ApiResponse<Media>> => {
    const endpoint = `${BASE_MEDIA_PATH}/`;
    return await fetchApi.post<Media>(endpoint, formData);
  }
};


"use client";

import React, { useState, useEffect, useCallback, useMemo, useReducer } from 'react';
import { mediaApi } from '@/api/media/route';
import { Media } from '@/types/shared/media';

// 1. Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² useReducer Ø¨Ø±Ø§ÛŒ filters
type FilterAction = 
  | { type: 'SET_SEARCH'; payload: string }
  | { type: 'SET_FILE_TYPE'; payload: string }
  | { type: 'SET_PAGE'; payload: number }
  | { type: 'RESET' };

const filterReducer = (state: any, action: FilterAction) => {
  switch (action.type) {
    case 'SET_SEARCH':
      return { ...state, search: action.payload, page: 1 };
    case 'SET_FILE_TYPE':
      return { ...state, file_type: action.payload, page: 1 };
    case 'SET_PAGE':
      return { ...state, page: action.payload };
    case 'RESET':
      return {
        search: "",
        file_type: "all",
        page: 1,
        limit: 12,
        ordering: "-created_at",
      };
    default:
      return state;
  }
};

interface MediaLibraryModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (selectedMedia: Media[] | Media) => void;
  selectMultiple?: boolean;
  initialFileType?: string;
}

export function MediaLibraryModal(props: MediaLibraryModalProps) {
  const { isOpen, onClose, onSelect, selectMultiple = false, initialFileType = "all" } = props;
  
  const [filters, dispatch] = useReducer(filterReducer, {
    search: "",
    file_type: initialFileType,
    page: 1,
    limit: 12,
    ordering: "-created_at",
  });

  const [mediaItems, setMediaItems] = useState<Media[]>([]);
  const [totalCount, setTotalCount] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [selectedMedia, setSelectedMedia] = useState<Record<string | number, Media>>({});

  // 2. Memoize fetchMedia
  const fetchMedia = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await mediaApi.getMediaList(filters, { cache: 'no-store' });
      if (response.metaData.status === 'success') {
        setMediaItems(Array.isArray(response.data) ? response.data : []);
        setTotalCount(response.pagination?.count || 0);
      }
    } catch (error) {
      console.error('Error fetching media:', error);
      setMediaItems([]);
      setTotalCount(0);
    } finally {
      setIsLoading(false);
    }
  }, [filters]);

  // 3. Fetch only when filters change
  useEffect(() => {
    if (isOpen) {
      fetchMedia();
    }
  }, [isOpen, fetchMedia]);

  // 4. Memoize handlers
  const handleSearchChange = useCallback((value: string) => {
    dispatch({ type: 'SET_SEARCH', payload: value });
  }, []);

  const handleFileTypeChange = useCallback((type: string) => {
    dispatch({ type: 'SET_FILE_TYPE', payload: type });
  }, []);

  const handlePageChange = useCallback((page: number) => {
    dispatch({ type: 'SET_PAGE', payload: page });
  }, []);

  // 5. Memoize selected media array
  const selectedMediaArray = useMemo(() => {
    return Object.values(selectedMedia);
  }, [selectedMedia]);

  // 6. Memoize media grid
  const MediaGrid = useMemo(() => (
    <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-3">
      {mediaItems.map((item) => (
        <MediaCard
          key={item.id}
          media={item}
          isSelected={!!selectedMedia[item.id]}
          onSelect={() => {
            setSelectedMedia(prev => {
              const newSelection = { ...prev };
              if (newSelection[item.id]) {
                delete newSelection[item.id];
              } else {
                if (!selectMultiple) {
                  return { [item.id]: item };
                }
                newSelection[item.id] = item;
              }
              return newSelection;
            });
          }}
        />
      ))}
    </div>
  ), [mediaItems, selectedMedia, selectMultiple]);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        {/* Search Input */}
        <Input
          value={filters.search}
          onChange={(e) => handleSearchChange(e.target.value)}
          placeholder="Ø¬Ø³ØªØ¬Ùˆ..."
        />

        {/* Media Grid */}
        {isLoading ? <Loader /> : MediaGrid}

        {/* Footer */}
        <Button onClick={() => {
          onSelect(selectMultiple ? selectedMediaArray : selectedMediaArray[0]);
          onClose();
        }}>
          Ø§Ù†ØªØ®Ø§Ø¨ ({selectedMediaArray.length})
        </Button>
      </DialogContent>
    </Dialog>
  );
}

// 7. Memoize MediaCard
const MediaCard = React.memo<{
  media: Media;
  isSelected: boolean;
  onSelect: () => void;
}>(({ media, isSelected, onSelect }) => {
  return (
    <div
      onClick={onSelect}
      className={isSelected ? 'border-primary' : ''}
    >
      {/* Media Preview */}
    </div>
  );
});

MediaCard.displayName = 'MediaCard';


// api/media/route.ts - Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ caching

export const mediaApi = {
  /**
   * Get media list with smart caching
   */
  getMediaList: async (
    filters?: MediaFilter,
    options?: {
      cache?: RequestCache;
      revalidate?: number | false;
      cookieHeader?: string;
      forceRefresh?: boolean; // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§ÛŒÙ† Ú¯Ø²ÛŒÙ†Ù‡
    }
  ): Promise<ApiResponse<Media[]>> => {
    try {
      // Determine cache strategy based on context
      let cacheStrategy: RequestCache = 'no-store';
      let revalidate: number | false = false;

      if (!options?.forceRefresh) {
        // Ø¨Ø±Ø§ÛŒ Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…ÙˆÙ…ÛŒ: Ú©Ø´ Ø¨Ø§ revalidate
        if (!filters?.search && !filters?.date_from && !filters?.date_to) {
          cacheStrategy = 'force-cache';
          revalidate = 60; // 1 minute
        }
        // Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ: Ú©Ø´ Ú©ÙˆØªØ§Ù‡â€ŒÙ…Ø¯Øª
        else if (filters?.search) {
          cacheStrategy = 'default';
          revalidate = 30; // 30 seconds
        }
      }

      const fetchOptions = {
        cache: options?.cache ?? cacheStrategy,
        revalidate: options?.revalidate ?? revalidate,
        tags: [MEDIA_CACHE_TAG],
        cookieHeader: options?.cookieHeader,
      };

      // ... rest of the code
      const response = await fetchApi.get<Media[]>(endpoint, fetchOptions);
      return response;
    } catch (error: unknown) {
      // Error handling
    }
  },

  /**
   * Invalidate media cache
   */
  invalidateCache: () => {
    // Ø¯Ø± Next.js 15 Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² revalidateTag
    if (typeof window === 'undefined') {
      // Server-side
      const { revalidateTag } = require('next/cache');
      revalidateTag(MEDIA_CACHE_TAG);
    } else {
      // Client-side: force refresh
      window.location.reload();
    }
  }
};

// Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± components:
// Ø¨Ø±Ø§ÛŒ Ù„ÛŒØ³Øª Ø¹Ù…ÙˆÙ…ÛŒ (Ú©Ø´ Ù…ÛŒâ€ŒØ´ÙˆØ¯):
const response = await mediaApi.getMediaList({ page: 1, size: 12 });

// Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ (Ú©Ø´ Ú©ÙˆØªØ§Ù‡â€ŒÙ…Ø¯Øª):
const response = await mediaApi.getMediaList({ search: 'test' });

// Ø¨Ø±Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯/Ø­Ø°Ù (Ø¨Ø¯ÙˆÙ† Ú©Ø´ + invalidate):
await mediaApi.uploadMedia(formData);
mediaApi.invalidateCache(); // Ú©Ø´ Ø±Ø§ Ù¾Ø§Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯